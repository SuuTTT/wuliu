## 介绍

本需求文档是甲方提供的需求原材料


## 用户需求

### 第一组需求 6.6

对用户需求的描述，包括功能需求和性能需求。

接口名称: sptp/ckylcxByTwsj
接口功能:基于天文时间进行仓库余量查询
请求方式:POST
请求参数:｛spxqxx:{[{“spnm":“xx”, “zwkssj
:“2023-06-06 12:00:09"}]}

String spnm 商品内码
Date zwkssj 最晚开始时间(用订单需求时间减去调配成本)。

返回结果:｛“code”;200,“data”: [ {"ckkcsj VOS"：[{"sjjd”:“2023-06-06 12:00:00”, "ckkcvos":[{cknm”:"01”,“xyl":50.0},{“cknm”: '02”,"xyl’:100.0},{"cknm”:"03”, "xyl”:200.0}]}]，“spnm”:“01”}]

ckkcsjVOS：用于封装某个商品在某个时间节点在各个仓库的储备情况
ckkcvos：封装仓库的储备情况
Sjjd:时间节点
cknm:仓库内码
xyl：现有量
CKKCVOS:仓库数据

---
接口名称:sptp/queryYscb

接口功能:查询从某仓库运输某货物到下订单

的公司的总调配成本（出库时间十运输成来+提收成本）

请求方式:POST	

请求参数:

String pnm 商品内码

String cknm 仓库内码

double jd 下订单公司的经度

double wd 下订单公司的纬度

double sl 商品数量

String lg 量纲(吨/个)


返回结果: ｛“code”：200，“date”: 36.0｝

此处data的值为double类型

单位为小时

---

计算返回结果数据结构
String cknm 仓库内码
String qynm 企业内码
String spnm 商品内码
Date xqsj 需求时间(从订单中取值)
double cb(用提供的查询总调配成本接口得到的值赋值)

请求参数


{

"Spdd":[

{

"ddnm":"订单内码"，

"qynm":"提交商品订单企业内码"，"spnm":"商品内码"，"sl":"商品数量"，"lg":"量纲"，

"zwdpwcsj":"最晚商品调配完成时间",

"ckdata":[{"cknm":"xx","pfwhnm":"xx","yscb":6.0},"cknm":"xx","pfwhnm":"xx","yscb":6.0}]｝//yscb只是仓库到订单的运输成本，总调配成本是运输成本加出库成本

]，

"spmzd":"商品满足度"，"dpsx":"调配顺序"｝

---

订单这还有一个问题要考虑，就是今天说的虚拟时间，就是给的订单里面需求时间都是A+n这种样子的

---
对的，我输入的订单里有经纬度，可以确定你的订单最终要送到哪个网格，现在的问题是仓库到你的订单送达的网格的运输成本，有个约束条件是平时和特殊情况，会影响仓库的排序，这个数据应该是你自己模拟的，到时候要接入我们做好的表格数据

---
同时段只有一种货物。 假设计算出A订单在6月6日12：00在A仓库开始搬运商品，要搬运到18：00才能完成出库，同时计算出B订单在6月6日14：00在A仓库开始搬运商品，此时订单冲突，对于B订单来说A仓库是不可用状态（暂不实现）

### 第二组需求

实现时间约束

开始搬运时间=最晚商品调配完成时间（输入中有）-总调配时间（queryYscb接口查询获取）
结束搬运时间=最晚商品调配完成时间（输入中有）-运输时间（getZytpcl接口中ckData.yscb）
假设计算出A订单在6月6日12：00在A仓库开始搬运商品，要搬运到18：00才能完成出库，同时计算出B订单在6月6日14：00在A仓库开始搬运商品(在A订单的搬运时间段内12：00-18：00)，此时订单冲突，对于B订单来说A仓库是不可用状态

---
传给/getZytpcl只是仓库到订单的运输成本，总调配成本是运输成本加出库成本

### 第三组需求（bug反馈）
---
算法问题

2：分配商品数量超过仓库余量，未从第二个仓库分配
3：考虑运输和出库成本问题，

---

一算法问题
1没有自己维护仓库实时库存，因计算过程中没有交互，所以每次查到的库存值是一样的
2库存不足时，计算成本没有按可分配数量计算
第一个你计算是一次性的，中间没有改我们这边的库存查到的值永远不会变，你要自己维护实时库存，不然就无限调配了
第二个，你返回结果里传的是库存，但是调成本接口传的是订单里的数量，应该按实际能分配的数据传(xyl)，而不是需求量

---

真正用起来怎么会没冲突，算法就是为了检验人发现不了的冲突的

---

主要原则，所有订单尽可能处理，有结果就返回
1，总库存<订单需求量时，按给定仓库顺序逐库分配，能分配多少分配多少
2，第一条订单处理完成后，第二条订单与第一条订单在某一仓库存在时间冲突时，跳过该仓库，从后面仓库继续分配

约束放宽，尽量满足所有订单

第一二个约束不要，能分配多少分多少，分完所有仓库库存为止，第三个约束只能跳过时间冲突的仓库，下一个仓库如果不冲突也要继续分配

我昨天试了把你的所有约束都放开，结果中会出现0和负值，这块逻辑需要加大于0的判断处理

如果因为约束导致大部分订单无法满足，请遵循主要原则：所有订单尽可能处理，有结果就返回
1，总库存<订单需求量时，按给定仓库顺序逐库分配，能分配多少分配多少
2，第一条订单处理完成后，第二条订单与第一条订单在某一仓库存在时间冲突时，跳过该仓库，从后面仓库继续分配

所有仓库都跳过了？


## 用户数据

```json
测试数据：
{
	"spmzd":"95",
	"Spdd":[
		{
			"ddnm":"01",
			"qynm":"qynm1",
			"zwdpwcsj":"2023-06-290T00:00:00",
			"spnm":"01",
			"sl":"230",
			"lg":"个"
		},
		{
			"ddnm":"02",
			"qynm":"qynm2",
			"zwdpwcsj":"2023-06-30T00:00:00",
			"spnm":"02",
			"sl":"130",
			"lg":"个"
		}
	],
	"dpsx":"调配顺序"
}
查询成本返回数据：
{// confusing, this is query not return.
	"ckdata":[
		{
			"yscb":2.0,
			"pfwhnm":"BOX1",
			"cknm":"01"
		},
		{
			"yscb":1.0,
			"pfwhnm":"BOX2",
			"cknm":"02"
		}
	],
	"ddnm":"6",
	"qynm":"678",
	"zwdpwcsj":"2023-06-30T00:00:00",
	"spnm":"01",
	"sl":1,
	"jd":39.913818,
	"lg":"个",
	"wd":116.363625
}

查询仓库余量返回数据：
{
	"code":200,
	"data":[
		{
			"ckkcsjVOS":[
				{
					"sjjd":"2023-06-06 12:00:00",
					"ckkcvos":[
						{
							"cknm":"01",
							"xyl":100
						},
						{
							"cknm":"02",
							"xyl":200.0
						}
					]
				}
			],
			"spnm":"01"
		},
		{
			"ckkcsjVOS":[
				{
					"sjjd":"2023-06-06 12:00:00",
					"ckkcvos":[
						{
							"cknm":"01",
							"xyl":50.0
						},
						{
							"cknm":"02",
							"xyl":100.0
						}
					]
				}
			],
			"spnm":"02"
		}
	]
}
```

两个订单从一个仓库调同一个商品，库存100，第一个仓库调50，第二个仓库调100

正常情况应该是每个订单各调50或者一个调100一个调0看谁前谁后


两个订单，两种商品，三个仓库把情况覆盖到就行，有多库分配，有超库存，有时间冲突就行


订单6改成需求15 时间改成冲突时间6订单无法从WH1出