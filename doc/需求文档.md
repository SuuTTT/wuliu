# 需求文档
本文档详细分析了甲方的用户需求。甲方已经提供了两个接口，由我们负责编写第三个接口（getZytpcl）的需求和规格。

## 接口描述

### 接口一：获取仓库库存

#### 接口功能

获取特定时间段内各个仓库的商品库存信息。

#### 请求方式

POST

#### 接口地址

http://localhost:8000/sptp/ckylcxByUTC

#### 请求参数

```json
{
  "spxqxx": [
    {
      "spnm": "商品内码",
      "zwkssj": "最晚开始时间"
    }
  ]
}
```

其中，
- `spxqxx` (数组): 商品详情信息列表。每个元素包含以下字段：
  - `spnm` (字符串): 商品内码。
  - `zwkssj` (日期): 最晚开始时间。如果此字段不存在，使用订单的`zwdpwcsj`字段（最晚调配完成时间）。

#### 返回结果

```json
{
  "code": 200,
  "data": [
    {
      "ckkcsj VOS": [
        {
          "sjjd": "时间节点",
          "ckkcvos": [
            {"cknm": "仓库内码", "xyl": 50.0},
            {"cknm": "仓库内码", "xyl": 100.0},
            {"cknm": "仓库内码", "xyl": 200.0}
          ]
        }
      ],
      "spnm": "商品内码"
    }
  ]
}
```

### 接口二：获取总调配成本

#### 接口功能

查询从某仓库运输某货物到特定坐标的总调配成本，包括出库时间和运输成本。

#### 请求方式

POST

#### 接口地址

http://localhost:8000/sptp/queryYscb

#### 请求参数

```json
{
  "spnm": "商品内码",
  "cknm": "仓库内码",
  "jd": "经度",
  "wd": "纬度",
  "sl": "商品数量",
  "lg": "量纲"
}
```

其中，
- `spnm` (字符串): 商品内码。
- `cknm` (字符串): 仓库内码。
- `jd` (浮点数): 下订单公司的经度。
- `wd` (浮点数): 下订单公司的纬度。
- `sl` (浮点数): 商品数量。
- `lg` (字符串): 量纲。

#### 返回结果

```json
{
  "code": 200,
  "data": 36.0
}
```
其中，`data` (浮点数): 总调配成本，单位为小时。

### 接口三：获取最优调配策略

#### 接口功能

根据订单信息和仓库数据计算并返回最优调配策略。

#### 请求方式

POST

#### 接口地址

http://localhost:8000/getZytpcl

#### 请求参数

```json
{
  "Spdd": [
    {
      "ddnm": "订单内码",
      "qynm": "提交商品订单企业内码",
      "spnm": "商品内码",
      "sl": "商品数量",
      "lg": "量纲",
      "zwdpwcsj": "最晚商品调配完成时间",
      "ckdata": [
        {
          "cknm": "仓库内码",
          "pfwhnm": "剖分网盒内码",
          "yscb": 6.0
        },
        {
          "cknm": "仓库内码",
          "pfwhnm": "剖分网盒内码",
          "yscb": 6.0
        }
      ]
    }
  ],
}
```

其中，

- `Spdd` (数组): 订单列表。每个元素包含以下字段：
  - `ddnm` (字符串): 订单内码。
  - `qynm` (字符串): 提交商品订单企业内码。
  - `spnm` (字符串): 商品内码。
  - `sl` (浮点数): 商品数量。
  - `lg` (字符串): 量纲。
  - `zwdpwcsj` (日期): 最晚商品调配完成时间。
  - `ckdata` (数组): 仓库数据。每个元素包含以下字段：
    - `cknm` (字符串): 仓库内码。
    - `pfwhnm` (字符串): 配发仓库内码。
    - `yscb` (浮点数): 运输成本。注意，这只是仓库到订单的运输成本，总调配成本是运输成本加出库成本。

- `spmzd` (字符串): 商品满足度。
- `dpsx` (字符串): 调配顺序。

#### 返回结果

```json
{
  "code": 200,
  "data": [
    {
      "cknm": "仓库内码",
      "qynm": "企业内码",
      "spnm": "商品内码",
      "xqsj": "需求时间",
      "cb": "总调配成本"
    }
  ]
}
```

其中，返回的数据是一个最优调配策略列表，每个元素包含以下字段：


- `cknm` (字符串): 仓库内码。
- `qynm` (字符串): 企业内码。
- `spnm` (字符串): 商品内码。
- `xqsj` (日期): 需求时间，从订单中取值。
- `ksbysj`(日期)：开始搬运时间，为“最晚商品调配完成时间”减去“总调配时间（queryYscb返回的data项）”
- `jsbysj`(日期)：结束搬运时间，为“最晚商品调配完成时间”减去“运输时间（yscb）”
- `cb` (浮点数): 总调配成本，用查询总调配成本接口得到的值赋值。
- `sl` (整数/浮点数): 分配的数量为仓库的库存量。
- `lg` (字符串): 单位。
- `jd` (浮点数): 经度。
- `wd` (浮点数): 纬度。
- `ddnm` (字符串): 订单内码。


## 业务描述

### 概述
为一个物流系统实现一个最优调配策略接口（@app.route("/getZytpcl", methods=['POST'])  def getZytpcl()# 获取最优调配策略）负责从多个仓库运送多种商品以满足多个客户订单的需求。你的目标是在满足所有订单需求，时间不冲突和库存充足约束下，尽可能降低整体的物流成本。

具体来说，库存和运输成本信息已知的情况下（通过接口查询/queryYscb /ckylcxByUTC），对于输入的订单列表，输出最优调配策略列表。

几个注意点，不要做多余的假设：

- 多种商品：仓库里有多种商品，每个订单只会请求一种商品
- 多个仓库：单个订单可由多个仓库供货（订单中附带有可向该订单供货的仓库），比如分配给某订单的商品数量超过仓库余额时，算法应该能够自动从另一个仓库进行分配。即，一个订单可以对应多个调配策略。
- 地理信息：客户有经纬度属性，仓库有剖分网盒内码。订单中用经纬度表示发出请求的客户
- 时间信息：时间以UTC的格式给出2023-06-30T00:00:00。我们首先设定一个调配策略的“开始搬运时间”为“最晚商品调配完成时间”减去“总调配时间”，同时设定“结束搬运时间”为“最晚商品调配完成时间”减去“运输时间”。

### 约束 


a. 库存：从仓库分配出去的商品总量不能超过仓库的可用库存。

b. 时间：同一仓库在特定时间段内仅可出货一种商品。具体来说，例如，若订单A的搬运开始时间为6月6日12:00，结束时间为18:00，而订单B的搬运开始时间为6月6日14:00，由于这两个时间段冲突，订单B无法使用订单A所用的仓库。

c. 优先级：必须严格按照订单在输入列表的先后顺序分配优先级，保证尽可能及时地满足前面的订单。（不要按时间排序）

### 注意事项和详细需求
1. **需求一：** 应避免遍历`spnm`，因为`spnm`字符串有特殊含义，不可拆分，算法设计时需要保证`spnm`的完整性。

3. **需求三：** 算法应包含运输和出库成本的计算逻辑，以考虑运输和出库成本。

5. **需求五：** 算法需要自行维护仓库实时库存，因为在计算过程中无法进行实时交互，所以每次查询得到的库存值是固定的，这需要避免出现无限调配的情况。

6. **需求六：** 当库存不足时，应按照可分配数量（而非需求量）来计算成本。即，当调用成本接口时，应传入实际可分配的数量数据。
