# 需求文档
本文档详细分析了甲方的需求。根据甲方提供的需求，BUG反馈（附带错误测试样例）和接口（/queryYscb /ckylcxByUTC），由本团队负责编写第三个接口（getZytpcl），以通过甲方的所有测试。

## 业务描述 V1.1

### 需求概述
为物流系统实现一个最优调配策略算法，对于输入的订单列表，在库存和运输成本信息已知的情况下，输出最优调配策略列表。目标是在给定约束下尽可能降低成本，提升订单的满足率。
分配需要遵循以下规则：
- 订单最大化处理: 所有的订单应尽可能被处理，即使某些订单的请求数量可能无法完全满足。
- 多仓库供货: 当所有仓库的总库存少于某订单的需求量时，算法应按照给定的仓库顺序逐库分配商品。
- 每个订单只会请求一种商品，但是一个仓库可能有多种商品。



输入：
订单列表：通过请求值的方式输入给我们的算法（接口getZytpcl）。订单信息包括订单号、商品内码、请求数量、最晚商品调配完成时间、订单的仓库列表（仓库编号、仓库库存、运输时间）。
库存和运输成本：是请求接口/queryYscb /ckylcxByUTC得到的返回值，订单信息。

输出：
最优调配策略。

输入输出格式：
见接口描述。




### 约束 

1. 满足所有订单：订单收到的商品总量大于等于其请求的数量

2. 库存：从仓库分配出去的商品总量不能超过仓库的可用库存。

3. 出库的时间约束：同一仓库在特定时间段内仅可为一个调配策略出库。具体来说，我们定义一个调配策略的“开始搬运时间”为“最晚商品调配完成时间”减去“总调配时间”，同时设定“结束搬运时间”为“最晚商品调配完成时间”减去“运输时间”。例如，若调配策略A的搬运开始时间为6月6日12:00，结束时间为18:00，而调配策略B的搬运开始时间为6月6日14:00，则这两个时间段冲突，这样的调配策略列表不是一个合法的解。
- 时间冲突处理: 算法需要能处理订单在仓库之间的时间冲突。具体来说，如果算法在处理第二条订单时发现它与第一条订单在某个仓库存在时间冲突，那么它应跳过这个仓库，从后续的仓库继续分配。




**现在让我们深入探讨第三项约束，也就是时间约束。这个约束在当前版本中已经引发了一系列问题，我们从13号开始的新版本以及之后的bug反馈主要集中在此问题上。**

>（约束来源：何育龙6.6线下讨论提出时间约束并于6.13给出具体公式）假设计算出A订单在6月6日12：00在A仓库开始搬运商品，要搬运到18：00才能完成出库，同时计算出B订单在6月6日14：00在A仓库开始搬运商品，此时订单冲突，对于B订单来说A仓库是不可用状态
开始搬运时间=最晚商品调配完成时间（输入中有）-总调配时间（queryYscb接口查询获取）
结束搬运时间=最晚商品调配完成时间（输入中有）-运输时间（getZytpcl接口中ckData.yscb）

首先，我们根据上文，明确以下几个已知的参数及其获取方式：

1. **总调配时间 $T_{total, i}$**：这是策略 $i$ 的总调配时间，通过调用 `/queryYscb` 接口获得。

2. **运输时间 $T_{transport, i}$**：这是策略 $i$ 的运输时间，通过从 `/getZytpcl` 请求参数中的 `Spdd.ckdata.yscb` 获取。

3. **最晚商品调配完成时间 $T^{end}_{max, i}$**：这是订单 $i$ 的最晚商品调配完成时间，从 `/getZytpcl` 请求参数中的 `Spdd.zwdpwcsj` 获取。

有了以上已知参数，我们就可以计算出剩下的参数：

- **搬运时间 $T_{handling, i}$**：这是策略 $i$ 的搬运时间，计算方式为总调配时间 $T_{total, i}$ 减去运输时间 $T_{transport, i}$。

    $$ T_{handling, i} = T_{total, i} - T_{transport, i} $$

- **开始搬运时间 $T^{start}_{i}$**：这是策略 $i$ 的开始搬运时间，计算方式为最晚商品调配完成时间 $T^{end}_{max, i}$ 减去总调配时间 $T_{total, i}$。

    $$ T^{start}_{i} = T^{end}_{max, i} - T_{total, i} $$

- **结束搬运时间 $T^{end}_{i}$**：这是策略 $i$ 的结束搬运时间，计算方式为最晚商品调配完成时间 $T^{end}_{max, i}$ 减去运输时间 $T_{transport, i}$。

    $$ T^{end}_{i} = T^{end}_{max, i} - T_{transport, i} $$

针对约束条件 b，出库的时间约束，我们首先需要了解的是同一仓库在特定时间段内仅可为一个调配策略出库。这意味着，对于任何一个特定仓库，如果已经有一个策略在某个时间段内搬运商品，那么在该时间段内不应有其他策略同时在该仓库进行搬运。如果存在这样的情况，我们就说这两个策略在时间上发生了冲突。

更具体地，对于仓库 $j$ 和策略 $i$ 和 $k$，如果 $T^{start}_{i} < T^{end}_{k}$ 并且 $T^{end}_{i} > T^{start}_{k}$，那么我们就说策略 $i$ 和策略 $k$ 在仓库 $j$ 上存在时间冲突。

因此，我们可以将这个约束条件形式化如下：

$$ \forall i, k, j: T^{start}_{i} \geq T^{end}_{k} \quad or \quad T^{end}_{i} \leq T^{start}_{k} $$

当我们在处理订单和分配策略时，如果发现某个订单在某个仓库存在时间冲突，那么我们就应该跳过这个仓库，转而考虑其他的仓库进行商品调配。这样，我们可以确保满足每个仓库的出库时间约束，避免了同一时间段内多个策略在同一个仓库中搬运商品的情况出现。

对应的实现代码为(来自optimizer.py的is_valid函数)：

```python
    # Check the first constraint. 满足所有订单
    for ddnm, strategies in strategies_by_ddnm.items():
        total_sl = sum(strategy["sl"] for strategy in strategies)
        # If the sum of 'sl' for a specific 'ddnm' is less than the 'sl' of the order, return False.
        if total_sl < sl_for_order[ddnm]:
            return False

    # Check the second constraint. 库存约束
    for (cknm, spnm), strategies in strategies_by_cknm_spnm.items():
        total_sl = sum(strategy["sl"] for strategy in strategies)
        # If the sum of 'sl' for a specific 'cknm' and 'spnm' is greater than the 'xyl' of the warehouse, return False.
        if total_sl > get_warehouse_capacity(cknm, spnm, strategies[0]["xqsj"].isoformat()):
            return False

    # Check the third constraint. 出库的时间约束
    for cknm, strategies in strategies_by_cknm.items():
        # Sort the strategies by 'ksbysj'.
        strategies.sort(key=lambda strategy: strategy["ksbysj"])
        # If any two adjacent strategies have overlapping time intervals, return False.
        for i in range(len(strategies) - 1):
            if strategies[i]["jsbysj"] > strategies[i + 1]["ksbysj"]:
                return False
```


### 后续改进需求（待讨论）

- 地理信息：
  在当前版本中，我们没有考虑地理信息的影响。但在现实世界中，仓库与目标地点的地理位置会对物流产生深远影响，如仓库与目标地点的距离、交通状况等都会影响运输的成本和时间。

#### 额外考虑的约束：

- 库存动态变化：在物流系统中，库存是动态变化的。新的商品会入库，已有的商品会被调配出去。因此，库存的动态变化需要作为一个约束进行考虑。

- 调配优先级：实际的物流系统中可能会出现一些紧急的订单，这些订单可能需要优先进行调配，即使这会增加成本。

- 调配稳定性：在连续的调配过程中，我们应尽可能保持单个仓库或目的地的出入货量稳定，以减少因出入货量波动造成的额外成本。

- 配送路线优化：在多订单、多仓库的环境中，配送路线的优化可以显著减少物流成本。例如，应用车辆路径问题(Vehicle Routing Problem, VRP)的解决策略可以有效地规划出高效的配送路线。

- 多模式运输：在实际物流系统中，可能存在多种运输模式，如公路、铁路、航空等，它们在运输速度、成本等方面有所差异。我们应该考虑在满足时间和成本约束的情况下选择最佳的运输模式。

#### 可扩展性：

- 时间信息的引入：在当前版本中，我们已经使用了出库时间作为一个约束。然而，还有很多其他的时间信息可以被考虑，如订单的下单时间、仓库的开放时间等。

- 成本的扩展：在现有的基础上，我们可以进一步引入更多的成本因素，如库存成本、运输成本、订单满足率对成本的影响等。

- 服务满足度的优化：考虑到一些特殊情况，如急单、VIP客户等，我们可能需要优化服务满足度，即尽可能满足这些订单，即使这可能增加成本。

- 多目标优化：在实际问题中，我们可能需要同时优化多个目标，如成本、时间、服务满足度等。这需要我们采用多目标优化算法进行问题求解。






## 业务需求 v1.2



## 接口描述

### 接口一：获取仓库库存

#### 接口功能

此接口的功能是获取特定时间段内各个仓库的商品库存信息。用户通过POST请求发送一个包含特定商品内码和最晚开始时间的JSON**列表**到服务器，服务器则会回传一个包含商品内码以及与该商品相关的所有仓库的库存信息的JSON列表。在回传的JSON列表中，每个仓库的库存信息包括仓库内码和对应的库存量。

#### 请求方式

POST

#### 接口地址

http://localhost:8000/sptp/ckylcxByUTC

#### 请求参数

```json
{
  "spxqxx": [
    {
      "spnm": "商品内码",
      "zwkssj": "最晚开始时间" 
      //例如："2023-10-01", "2023-06-30T00:00:00", "2023-06-06 12:00:00"
    }
  ]
}

```

其中，
- `spxqxx` (数组): 商品详情信息列表。每个元素包含以下字段：
  - `spnm` (字符串): 商品内码。
  - `zwkssj` (日期): 最晚开始时间。支持多种格式，如："2023-10-01", "2023-06-30T00:00:00", "2023-06-06 12:00:00"。

#### 返回结果

```json
{
  "code": 200,
  "data": [
    {
      "ckkcsj VOS": [
        {
          "sjjd": "时间节点",
          "ckkcvos": [
            {"cknm": "仓库内码", "xyl": 50.0},
            {"cknm": "仓库内码", "xyl": 100.0},
            {"cknm": "仓库内码", "xyl": 200.0}
          ]
        }
      ],
      "spnm": "商品内码"
    }
  ]
}
```

### 接口二：获取总调配成本

#### 接口功能

查询从某仓库运输某货物到特定坐标的总调配成本，包括出库时间和运输成本。（小时）

#### 请求方式

POST

#### 接口地址

http://localhost:8000/sptp/queryYscb

#### 请求参数

```json
{
  "spnm": "商品内码",
  "cknm": "仓库内码",
  "jd": "经度",
  "wd": "纬度",
  "sl": "商品数量",
  "lg": "量纲"
}
```

其中，
- `spnm` (字符串): 商品内码。
- `cknm` (字符串): 仓库内码。
- `jd` (浮点数): 下订单公司的经度。
- `wd` (浮点数): 下订单公司的纬度。
- `sl` (浮点数): 商品数量。
- `lg` (字符串): 量纲。

#### 返回结果

```json
{
  "code": 200,
  "data": 36.0
}
```
其中，`data` (浮点数): 总调配成本，单位为小时。

### 接口三：获取最优调配策略

#### 接口功能

根据订单信息和仓库数据计算并返回最优调配策略。

#### 请求方式

POST

#### 接口地址

http://localhost:8000/getZytpcl

#### 请求参数

```json
{
  "Spdd": [
    {
      "ddnm": "订单内码",
      "qynm": "提交商品订单企业内码",
      "spnm": "商品内码",
      "sl": "商品数量",
      "lg": "量纲",
      "zwdpwcsj": "最晚商品调配完成时间",
      "ckdata": [
        {
          "cknm": "仓库内码",
          "pfwhnm": "剖分网盒内码",
          "yscb": 6.0
        },
        {
          "cknm": "仓库内码",
          "pfwhnm": "剖分网盒内码",
          "yscb": 6.0
        }
      ]
    }
  ],
}
```

其中，

- `Spdd` (数组): 订单列表。每个元素包含以下字段：
  - `ddnm` (字符串): 订单内码。
  - `qynm` (字符串): 提交商品订单企业内码。
  - `spnm` (字符串): 商品内码。
  - `sl` (浮点数): 商品数量。
  - `lg` (字符串): 量纲。
  - `zwdpwcsj` (日期): 最晚商品调配完成时间。
  - `ckdata` (数组): 仓库数据。每个元素包含以下字段：
    - `cknm` (字符串): 仓库内码。
    - `pfwhnm` (字符串): 配发仓库内码。
    - `yscb` (浮点数): 运输成本。注意，这只是仓库到订单的运输成本，总调配成本是运输成本加出库成本。

- `spmzd` (字符串): 商品满足度。
- `dpsx` (字符串): 调配顺序。

#### 返回结果

```json
{
  "code": 200,
  "data": [
    {
      "cknm": "仓库内码",
      "qynm": "企业内码",
      "spnm": "商品内码",
      "xqsj": "需求时间",
      "cb": "总调配成本",
      "sl": "分配的数量",
      "lg": "单位",
      "jd": "经度",
      "wd": "纬度",
      "ddnm": "订单内码"
    }
  ]
}
```

其中，返回的数据是一个最优调配策略列表，每个元素包含以下字段：


- `cknm` (字符串): 仓库内码。
- `qynm` (字符串): 企业内码。
- `spnm` (字符串): 商品内码。
- `xqsj` (日期): 需求时间，从订单中取值。
- `cb` (浮点数): 总调配成本，用查询总调配成本接口得到的值赋值。
- `sl` (整数/浮点数): 分配的数量为仓库的库存量。
- `lg` (字符串): 单位。
- `jd` (浮点数): 经度。
- `wd` (浮点数): 纬度。
- `ddnm` (字符串): 订单内码。



