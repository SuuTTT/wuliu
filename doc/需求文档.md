# 需求文档

本需求文档对客户需求进行了详细的剖析，为我们的物流系统设计和实现核心算法模块提供了明确的指南。我们的团队将专注于开发新的接口（getZytpcl），基于提供的订单列表和库存信息，生成最优化的调配策略，目的在于满足各项约束的前提下最大程度地降低总成本并提升订单满足率。

在业务需求v1.1中，我们回顾了6月23日提交的版本，其中提出了固定开始和结束搬运时间的假设。

在业务需求v1.2中，我们提出了一些关于接口修改和新增的建议，包括将开始搬运时间纳入到最优调配策略中，并且将运输时间与成本进行分离。此外，我们还针对未来的需求提出了一系列可能的改进，如考虑地理信息、库存动态变化、调配优先级、调配稳定性、配送路线优化以及多模式运输等方面。

根据客户提出的需求、BUG反馈（包含错误测试样例）以及已有的接口（/queryYscb /ckylcxByUTC），我们的团队将负责设计并实现新的接口（getZytpcl）以满足所有的客户测试。

## 业务描述 V1.1
在6月23日提交的1.1版本中，我们采纳了客户提出的一个简化假设：固定的开始搬运时间和结束搬运时间。这意味着，输入的订单的开始搬运时间和结束搬运时间是固定的。在仓库数量不足的情况下，可能会导致出库时间的重合，从而无法满足所有的订单。（即便是将订单拆解为多个数量不同的子订单，但只要最晚调配时间接近，仍然可能出现时间上的重叠。关于这一点的具体证明和讨论，请参见“约束-时间约束”小节。）
### 需求概述
本需求的核心目标是为物流系统实现一个最优调配策略算法。给定输入的订单列表，在知道库存信息和运输成本的情况下，算法能输出最优的调配策略列表。优化目标是在满足既定约束的条件下，最大限度地降低总成本，同时提高订单的满足率。

#### 调配策略需要遵循以下规则：

- 订单最大化处理：所有的订单都应该尽可能被处理，即使某些订单的需求数量可能无法被完全满足。
- 多仓库供货：当所有仓库的总库存小于某一订单的需求量时，算法应该按照给定的仓库顺序，逐个仓库分配商品。
- 商品单一性：每个订单只会请求一种商品，但是一个仓库可能存放多种商品。

#### 输入数据：

- 订单列表：通过发给接口（/getZytpcl）的请求数据传给算法。订单信息包括订单号、商品内码、需求数量、最晚商品调配完成时间、订单的仓库列表（包括仓库编号、仓库库存、运输时间）。
- 库存和运输成本：这些信息是调用接口/queryYscb /ckylcxByUTC得到的返回值。

#### 输出数据：

- 最优调配策略：/getZytpcl接口的返回值

具体的输入输出格式，详见接口描述部分。


#### 约束 

1. 满足所有订单：订单收到的商品总量大于等于其请求的数量

2. 库存：从仓库分配出去的商品总量不能超过仓库的可用库存。

3. 出库的时间约束：同一仓库在特定时间段内仅可为一个调配策略出库。具体来说，我们定义一个调配策略的“开始搬运时间”为“最晚商品调配完成时间”减去“总调配时间”，同时设定“结束搬运时间”为“最晚商品调配完成时间”减去“运输时间”。例如，若调配策略A的搬运开始时间为6月6日12:00，结束时间为18:00，而调配策略B的搬运开始时间为6月6日14:00，则这两个时间段冲突，这样的调配策略列表不是一个合法的解。
- 时间冲突处理: 算法需要能处理订单在仓库之间的时间冲突。具体来说，如果算法在处理第二条订单时发现它与第一条订单在某个仓库存在时间冲突，那么它应跳过这个仓库，从后续的仓库继续分配。



##### 时间约束
**让我们深度解析这第三项关键约束--时间约束。这个约束在当前版本中已经激发了一系列的复杂问题，从我们于13号发布的新版本开始，及其后的多次BUG反馈，几乎都聚焦在这一问题上。更为严重的是，通过理论证明，在某些特定情况下，这个约束会不可避免地导致部分订单无法得到满足。**

>（约束来源：何育龙6.6线下讨论提出时间约束并于6.13给出具体公式）假设计算出A订单在6月6日12：00在A仓库开始搬运商品，要搬运到18：00才能完成出库，同时计算出B订单在6月6日14：00在A仓库开始搬运商品，此时订单冲突，对于B订单来说A仓库是不可用状态
开始搬运时间=最晚商品调配完成时间（输入中有）-总调配时间（queryYscb接口查询获取）
结束搬运时间=最晚商品调配完成时间（输入中有）-运输时间（getZytpcl接口中ckData.yscb）

首先，我们根据上文，明确以下几个已知的参数及其获取方式：

1. **总调配时间 $T_{total, i}$**：这是策略 $i$ 的总调配时间，通过调用 `/queryYscb` 接口获得。

2. **运输时间 $T_{transport, i}$**：这是策略 $i$ 的运输时间，通过从 `/getZytpcl` 请求参数中的 `Spdd.ckdata.yscb` 获取。

3. **最晚商品调配完成时间 $T^{end}_{max, i}$**：这是订单 $i$ 的最晚商品调配完成时间，从 `/getZytpcl` 请求参数中的 `Spdd.zwdpwcsj` 获取。

有了以上已知参数，我们就可以计算出剩下的参数：

- **搬运时间 $T_{handling, i}$**：这是策略 $i$ 的搬运时间，计算方式为总调配时间 $T_{total, i}$ 减去运输时间 $T_{transport, i}$。

    $$ T_{handling, i} = T_{total, i} - T_{transport, i} $$

- **开始搬运时间 $T^{start}_{i}$**：这是策略 $i$ 的开始搬运时间，计算方式为最晚商品调配完成时间 $T^{end}_{max, i}$ 减去总调配时间 $T_{total, i}$。

    $$ T^{start}_{i} = T^{end}_{max, i} - T_{total, i} $$

- **结束搬运时间 $T^{end}_{i}$**：这是策略 $i$ 的结束搬运时间，计算方式为最晚商品调配完成时间 $T^{end}_{max, i}$ 减去运输时间 $T_{transport, i}$。

    $$ T^{end}_{i} = T^{end}_{max, i} - T_{transport, i} $$

针对约束条件 b，出库的时间约束，我们首先需要了解的是同一仓库在特定时间段内仅可为一个调配策略出库。这意味着，对于任何一个特定仓库，如果已经有一个策略在某个时间段内搬运商品，那么在该时间段内不应有其他策略同时在该仓库进行搬运。如果存在这样的情况，我们就说这两个策略在时间上发生了冲突。

更具体地，对于仓库 $j$ 和策略 $i$ 和 $k$，如果 $T^{start}_{i} < T^{end}_{k}$ 并且 $T^{end}_{i} > T^{start}_{k}$，那么我们就说策略 $i$ 和策略 $k$ 在仓库 $j$ 上存在时间冲突。

因此，我们可以将这个约束条件形式化如下：

$$ \forall i, k, j: T^{start}_{i} \geq T^{end}_{k} \quad or \quad T^{end}_{i} \leq T^{start}_{k} $$

当我们在处理订单和分配策略时，如果发现某个订单在某个仓库存在时间冲突，那么我们就应该跳过这个仓库，转而考虑其他的仓库进行商品调配。这样，我们可以确保满足每个仓库的出库时间约束，避免了同一时间段内多个策略在同一个仓库中搬运商品的情况出现。

然而**如果仓库不够，该订单就无法被满足**。我们可以通过下面的例子证明即使通过拆分订单来改变总调配时间 $T_{total, i}$， 如果两个订单的**最晚商品调配完成时间 $T^{end}_{max, i}$**相同，那么必然会有出库时间重叠。

> 证明：假设我们有两个订单A和B，它们的最晚商品调配完成时间 $T^{end}_{max}$ 是相同的，并且都需要从同一个仓库进行商品调配。
> 不论如何拆分这两个订单，改变总调配时间 $T_{total}$，这不会改变它们的最晚商品调配完成时间 $T^{end}_{max}$。这意味着无论如何调整，订单A和B的结束搬运时间（即最晚商品调配完成时间减去运输时间）始终是相同的。
> 为了避免时间重叠，我们必须确保它们的开始搬运时间（即最晚商品调配完成时间减去总调配时间）不相同。然而，由于它们的最晚商品调配完成时间是相同的，所以无论如何改变总调配时间，总会有一部分时间是它们的开始搬运时间相同，也就是说，它们的搬运时间段必然会有所重叠。
> 因此，即使通过拆分订单来改变总调配时间，如果两个订单的最晚商品调配完成时间相同，那么必然会有出库时间重叠。因此，为了避免出库时间的重叠，我们必须确保对于同一仓库，任何两个订单的最晚商品调配完成时间不相同。

对应的实现代码为(来自optimizer.py的is_valid函数)：


## 业务需求 v1.2
在最新的版本中，我们选择摒弃之前的简化假设，即固定的开始搬运时间和结束搬运时间，而选择将开始搬运时间纳入到最优调配策略中，作为待优化的变量。这将让我们的算法有更多的灵活性，以适应更多的实际场景。此外，这也将允许我们能够更有效地解决时间冲突的问题。

以下是我们针对 v1.2 版本的主要改动：


**最优化策略的改动：**我们将利用优化算法（如贪心算法或启发式算法）来解决时间冲突问题。通过寻找合适的开始搬运时间，我们将能够更有效地解决在同一仓库中同时进行多个订单的时间冲突问题。
为了更好地满足业务需求并提高系统的灵活性，我们建议客户进行以下接口修改：


1. **修改运输成本接口 `/queryYscb`**：该接口不再返回运输时间，而是返回其他运输的成本（如金钱成本或安全度），以实现时间和成本的分离。这样做的主要原因是，目前的 `/queryYscb` 接口在上一个版本中被用于计算时间约束，如果在未来需要替换其他的成本，将使现有的时间计算逻辑失去意义。因此，在优化过程中，我们需要分开考虑时间和成本。
2. **新增运输时间接口 `/queryYssj`**：我们建议新增一个 `/queryYssj` 接口，该接口将返回运输时间，从而让时间和成本得以分开处理。这一变动主要是因为，修订后的 `/queryYscb` 接口现在用于计算时间约束，而不再返回运输成本。

3. **新增出库时间窗口查询接口 `/queryCksj`**：最后，我们建议添加一个查询接口，该接口将返回每个仓库的出库时间窗口。这将帮助我们优化调配策略，避免在同一时间段，同一仓库内出现多个订单的情况。


我们期待这些改动能够帮助我们更好地优化调配策略，使我们的系统能够更灵活、更有效地适应各种不同的订单需求。

### 后续改进需求（待讨论）


#### 额外考虑的约束：

- 地理信息：
  在当前版本中，我们没有考虑地理信息的影响。但在现实世界中，仓库与目标地点的地理位置会对物流产生深远影响，如仓库与目标地点的距离、交通状况等都会影响运输的成本和时间。
  
- 库存动态变化：在物流系统中，库存是动态变化的。新的商品会入库，已有的商品会被调配出去。因此，库存的动态变化需要作为一个约束进行考虑。

- 调配优先级：实际的物流系统中可能会出现一些紧急的订单，这些订单可能需要优先进行调配，即使这会增加成本。

- 调配稳定性：在连续的调配过程中，我们应尽可能保持单个仓库或目的地的出入货量稳定，以减少因出入货量波动造成的额外成本。

- 配送路线优化：在多订单、多仓库的环境中，配送路线的优化可以显著减少物流成本。例如，应用车辆路径问题(Vehicle Routing Problem, VRP)的解决策略可以有效地规划出高效的配送路线。

- 多模式运输：在实际物流系统中，可能存在多种运输模式，如公路、铁路、航空等，它们在运输速度、成本等方面有所差异。我们应该考虑在满足时间和成本约束的情况下选择最佳的运输模式。

#### 可扩展性：

- 时间信息的引入：在当前版本中，我们已经使用了出库时间作为一个约束。然而，还有很多其他的时间信息可以被考虑，如订单的下单时间、仓库的开放时间等。

- 成本的扩展：在现有的基础上，我们可以进一步引入更多的成本因素，如库存成本、运输成本、订单满足率对成本的影响等。

- 服务满足度的优化：考虑到一些特殊情况，如急单、VIP客户等，我们可能需要优化服务满足度，即尽可能满足这些订单，即使这可能增加成本。

- 多目标优化：在实际问题中，我们可能需要同时优化多个目标，如成本、时间、服务满足度等。这需要我们采用多目标优化算法进行问题求解。

## 接口描述

### 接口一：获取仓库库存

#### 接口功能

此接口的功能是获取特定时间段内各个仓库的商品库存信息。用户通过POST请求发送一个包含特定商品内码和最晚开始时间的JSON**列表**到服务器，服务器则会回传一个包含商品内码以及与该商品相关的所有仓库的库存信息的JSON列表。在回传的JSON列表中，每个仓库的库存信息包括仓库内码和对应的库存量。

#### 请求方式

POST

#### 接口地址

http://localhost:8000/sptp/ckylcxByUTC

#### 请求参数

```json
{
  "spxqxx": [
    {
      "spnm": "商品内码",
      "zwkssj": "最晚开始时间" 
      //例如："2023-10-01", "2023-06-30T00:00:00", "2023-06-06 12:00:00"
    }
  ]
}

```

其中，
- `spxqxx` (数组): 商品详情信息列表。每个元素包含以下字段：
  - `spnm` (字符串): 商品内码。
  - `zwkssj` (日期): 最晚开始时间。支持多种格式，如："2023-10-01", "2023-06-30T00:00:00", "2023-06-06 12:00:00"。

#### 返回结果

```json
{
  "code": 200,
  "data": [
    {
      "ckkcsj VOS": [
        {
          "sjjd": "时间节点",
          "ckkcvos": [
            {"cknm": "仓库内码", "xyl": 50.0},
            {"cknm": "仓库内码", "xyl": 100.0},
            {"cknm": "仓库内码", "xyl": 200.0}
          ]
        }
      ],
      "spnm": "商品内码"
    }
  ]
}
```

### 接口二：获取总调配成本

#### 接口功能

查询从某仓库运输某货物到特定坐标的总调配成本，包括出库时间和运输成本。（小时）

#### 请求方式

POST

#### 接口地址

http://localhost:8000/sptp/queryYscb

#### 请求参数

```json
{
  "spnm": "商品内码",
  "cknm": "仓库内码",
  "jd": "经度",
  "wd": "纬度",
  "sl": "商品数量",
  "lg": "量纲"
}
```

其中，
- `spnm` (字符串): 商品内码。
- `cknm` (字符串): 仓库内码。
- `jd` (浮点数): 下订单公司的经度。
- `wd` (浮点数): 下订单公司的纬度。
- `sl` (浮点数): 商品数量。
- `lg` (字符串): 量纲。

#### 返回结果

```json
{
  "code": 200,
  "data": 36.0
}
```
其中，`data` (浮点数): 总调配成本，单位为小时。

### 接口三：获取最优调配策略

#### 接口功能

根据订单信息和仓库数据计算并返回最优调配策略。

#### 请求方式

POST

#### 接口地址

http://localhost:8000/getZytpcl

#### 请求参数

```json
{
  "Spdd": [
    {
      "ddnm": "订单内码",
      "qynm": "提交商品订单企业内码",
      "spnm": "商品内码",
      "sl": "商品数量",
      "lg": "量纲",
      "zwdpwcsj": "最晚商品调配完成时间",
      "ckdata": [
        {
          "cknm": "仓库内码",
          "pfwhnm": "剖分网盒内码",
          "yscb": 6.0
        },
        {
          "cknm": "仓库内码",
          "pfwhnm": "剖分网盒内码",
          "yscb": 6.0
        }
      ]
    }
  ],
}
```

其中，

- `Spdd` (数组): 订单列表。每个元素包含以下字段：
  - `ddnm` (字符串): 订单内码。
  - `qynm` (字符串): 提交商品订单企业内码。
  - `spnm` (字符串): 商品内码。
  - `sl` (浮点数): 商品数量。
  - `lg` (字符串): 量纲。
  - `zwdpwcsj` (日期): 最晚商品调配完成时间。
  - `ckdata` (数组): 仓库数据。每个元素包含以下字段：
    - `cknm` (字符串): 仓库内码。
    - `pfwhnm` (字符串): 配发仓库内码。
    - `yscb` (浮点数): 运输成本。注意，这只是仓库到订单的运输成本，总调配成本是运输成本加出库成本。

- `spmzd` (字符串): 商品满足度。
- `dpsx` (字符串): 调配顺序。

#### 返回结果

```json
{
  "code": 200,
  "data": [
    {
      "cknm": "仓库内码",
      "qynm": "企业内码",
      "spnm": "商品内码",
      "xqsj": "需求时间",
      "cb": "总调配成本",
      "sl": "分配的数量",
      "lg": "单位",
      "jd": "经度",
      "wd": "纬度",
      "ddnm": "订单内码"
    }
  ]
}
```

其中，返回的数据是一个最优调配策略列表，每个元素包含以下字段：


- `cknm` (字符串): 仓库内码。
- `qynm` (字符串): 企业内码。
- `spnm` (字符串): 商品内码。
- `xqsj` (日期): 需求时间，从订单中取值。
- `cb` (浮点数): 总调配成本，用查询总调配成本接口得到的值赋值。
- `sl` (整数/浮点数): 分配的数量为仓库的库存量。
- `lg` (字符串): 单位。
- `jd` (浮点数): 经度。
- `wd` (浮点数): 纬度。
- `ddnm` (字符串): 订单内码。



