## fixing

第一个你计算是一次性的，中间没有改我们这边的库存查到的值永远不会变，你要自己维护实时库存，不然就无限调配了

样例：
两个订单从一个仓库调同一个商品，库存100，第一个仓库调50，第二个仓库调100

正常情况应该是每个订单各调50或者一个调100一个调0看谁前谁后

## fixed
---
补丁1
goal：如果订单的需求量超过单个仓库的库存量，代码将会继续寻找下一个仓库，而不是在当前仓库分配一部分商品后再从其他仓库分配剩余的部分。


补丁2
goal：修改代码，改变`getZYtpcl中"cb": total_cost  # 添加成本` 的计算方法，这里的问题是，
get_total_costs的返回值由` "sl": dingdan["sl"],  # 商品数量`控制的，当订单由于单个仓库库存不够被拆分后，其对应的成本应该重新通过调用get_total_costs获得